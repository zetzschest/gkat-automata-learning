module Extra = struct
  type 't atom = 't list

  (* Turns an atom to a string. *)
  let atom_to_string (alpha: int atom) (tests: int list): string = 
    let rec f xs str = 
      match xs with 
      | [] -> str
      | hd :: tl -> 
        let x = "t" ^ (string_of_int hd) in
        if List.mem hd alpha then
          f tl (str ^ x)
        else
          f tl (str ^ "-" ^ x)
    in f tests ""

  (* 
  Given a function that turns an element of type 'a to a string, constructs a function that turns a 
  list of elements of type 'a to a string. 
  *)
  let string_list (f: 'a -> string): ('a list -> string) =
    fun (xs: 'a list) -> List.fold_left (fun (s: string) (a: 'a) -> s ^ f(a)) "" xs

  (* 
  Given a function that turns an element of type 'a to a string, and a function that turns an element 
  of type 'b to a string, constructs a function that turns a list of elements of type 'a * 'b to a string. 
  *)
  let string_two_lists (f: 'a -> string) (g: 'b -> string): ('a * 'b) list -> string = 
    let h (p: 'a * 'b): string = 
      let x = fst p in
      let y = snd p in 
      f(x) ^ g(y) ^ ";"
    in string_list h 

  (* Turns an integer into a "primitive test" string. *)
  let string_tests (t: int): string = 
    "t" ^ (string_of_int t)
  
  (* Turns an integer into a "primitive action" string. *)
  let string_actions (a: int): string = 
    "p" ^ (string_of_int a)

  (* Turns a word over the input alphabet of a KAT automaton into a string. *)
  let string_atoms_and_actions (xs: ((int list) * int) list) (tests: int list): string =
    let g alpha = 
      atom_to_string alpha tests
    in
    string_two_lists g string_actions xs

  (* Computes the atoms of the Boolean algebra generated by primitive tests. *)
  let from_tests_to_atoms (tests': 't list): ('t atom) list =
    let rec helper (tests: 't list) (current: ('t atom) list): ('t atom) list =
      match tests with 
      | [] -> current
      | tests_hd :: tests_tl -> 
          let rec f (xs: ('t atom) list): ('t atom) list =
            match xs with 
            | [] -> []
            | xs_hd :: xs_tl -> (tests_hd :: xs_hd) :: (f xs_tl)
          in helper tests_tl (current @ (f current)) 
    in helper tests' [[]]
  
  (* Essentially constructs the cartesian product. *)
  let rec list_times_list (xs: 'a list) (ys: 'b list): ('a * 'b) list =
      match xs with
      | [] -> []
      | hdxs :: tlxs -> 
          let rec f (zs: 'b list): ('a * 'b) list = 
            match zs with
            | [] -> []
            | hdzs :: tlzs -> (hdxs, hdzs) :: (f tlzs)
          in (f ys) @  list_times_list tlxs ys

  (* Essentially constructs the cartesian product between a list of atoms over primitive tests, and a list of actions. *)
  let from_tests_and_actions_to_atoms_and_actions (tests: 't list) (actions: 'a list): ('t atom * 'a) list =
    let atoms = from_tests_to_atoms tests in
    list_times_list atoms actions  

  (* Turns all atoms that satisfy f into a string. *)
  let subsets_of_atoms_to_string (f: 'a atom -> bool) (g: 'a atom -> string) (atoms: ('a atom) list) : string =
    let xs = List.filter f atoms in 
    List.fold_left (fun (s: string) (a: 'a atom) -> s ^ g(a) ^ ",") "" xs

  (* Given a (positive) integer n, constructs the list [1,...,n]. *)
  let range_from_one (n: int) : (int list) =
    let rec f (m: int) (xs: int list) = 
      if m = 0 then
        xs
      else
        f (m-1) (m :: xs)
    in f n []
end